// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Ownable} from "@openzeppelin/access/Ownable.sol";
import {Constants} from "../libraries/Constants.sol";

interface IGeneratedGroth16Verifier {
    function verifyProof(
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[4] calldata pubSignals
    ) external view returns (bool);
}

/// @notice Adapter from generic `(bytes proof, uint256[] publicInputs)` into the Solidity verifier shape generated by snarkjs.
contract Groth16VerifierAdapter is Ownable {
    IGeneratedGroth16Verifier public generatedVerifier;

    event GeneratedVerifierSet(address indexed verifier);

    error InvalidVerifierContract(address verifier);
    error InvalidProofLength(uint256 got, uint256 expected);
    error InvalidPublicInputCount(uint256 got, uint256 expected);
    error PublicInputOutOfField(uint256 index, uint256 value);

    constructor(address owner_, address verifier_) Ownable(owner_) {
        _setGeneratedVerifier(verifier_);
    }

    function setGeneratedVerifier(address verifier_) external onlyOwner {
        _setGeneratedVerifier(verifier_);
    }

    function verifyProof(bytes calldata proof, uint256[] calldata publicInputs) external view returns (bool) {
        if (publicInputs.length != 4) {
            revert InvalidPublicInputCount(publicInputs.length, 4);
        }
        if (proof.length != 32 * 8) {
            revert InvalidProofLength(proof.length, 32 * 8);
        }

        uint256[4] memory input;
        for (uint256 i = 0; i < 4; i++) {
            if (publicInputs[i] >= Constants.SNARK_SCALAR_FIELD) {
                revert PublicInputOutOfField(i, publicInputs[i]);
            }
            input[i] = publicInputs[i];
        }

        (uint256[2] memory pA, uint256[2][2] memory pB, uint256[2] memory pC) =
            abi.decode(proof, (uint256[2], uint256[2][2], uint256[2]));

        return generatedVerifier.verifyProof(pA, pB, pC, input);
    }

    function _setGeneratedVerifier(address verifier_) internal {
        if (verifier_ == address(0) || verifier_.code.length == 0) {
            revert InvalidVerifierContract(verifier_);
        }
        generatedVerifier = IGeneratedGroth16Verifier(verifier_);
        emit GeneratedVerifierSet(verifier_);
    }
}
