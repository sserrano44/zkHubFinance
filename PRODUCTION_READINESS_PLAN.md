# elhub Production Readiness Plan

This plan closes the remaining gaps between the current MVP and production deployment on Base (hub) + Worldchain (spoke).

## Exit Criteria

Production-ready means all items below are true:

1. Settlement uses real zero-knowledge proofs generated by the prover service and verified on-chain.
2. Supply/repay crediting is backed by canonical bridge attestations, not relayer/operator mint simulation.
3. Internal service APIs are authenticated and not publicly writable.
4. Relayer, indexer, and prover state is durable, idempotent, and reorg-safe.
5. Contracts and services have completed external security review and critical findings are resolved.
6. CI/CD and runbooks support repeatable testnet and mainnet release with rollback procedures.

---

## Phase 0 (Blockers)

### P0-1 Real ZK proving pipeline

Status: In progress (real proof plumbing implemented; full production constraints still pending).

Current blockers:
- Settlement correctness circuit still needs full lock/fill/deposit validity constraints.
- Generated verifier from final audited circuit not yet deployed in production envs.

Deliverables:
1. Replace scaffold circuit with real constraints:
   - Include/validate deposit commitments from spoke.
   - Include/validate lock + fill matching for borrow/withdraw.
   - Enforce amount/fee consistency against public inputs.
2. Generate proving and verification keys.
3. Deploy generated Solidity verifier contract.
4. Wire `CircuitProofProvider` to witness generation + proof generation.
5. Run `Verifier` with `DEV_MODE=false` and non-zero verifier contract.

Implemented:
1. `CircuitProofProvider` now executes `snarkjs groth16 fullprove` and ABI-encodes Groth16 proofs for on-chain submission.
2. `circom/SettlementBatchRoot.circom` replaced with a concrete deterministic action-root circuit.
3. Added `Groth16VerifierAdapter` contract to bridge generic `(bytes proof, uint256[] publicInputs)` into generated verifier signature.
4. Settlement action root is now SNARK-field-safe and deterministic across hub + prover.
5. Added artifact build script: `circuits/prover/build-artifacts.sh`.
6. Added production-verifier settlement tests that reject tampered proofs and accept valid proofs.
7. Deployment script supports `HUB_VERIFIER_DEV_MODE=0` + `HUB_GROTH16_VERIFIER_ADDRESS` to deploy prod verifier wiring.
8. Circuit-mode E2E wrappers were removed from active test commands after deposit-proof flow changes made them non-canonical/incompatible.

Acceptance criteria:
1. `PROVER_MODE=circuit` succeeds end-to-end without fallback to dev proof.
2. Settlement fails if proof/public inputs are tampered.
3. On-chain verification succeeds for valid batches and rejects invalid batches.
4. Batch size 50 can be proven and settled within defined SLO.

---

### P0-2 Canonical bridge attestation path for deposits

Status: In progress.

Current blockers:
- Deposit proof backend still needs full source-event validity constraints (light-client/ZK completeness).
- Local/fork test environments still rely on mocked Across SpokePools for transport simulation.

Deliverables:
1. Implement canonical bridge event ingestion in relayer/indexer:
   - Track spoke bridge send tx + hub bridge receive tx.
   - Persist source tx hash + log index + finality height.
2. Modify custody ingestion so deposits are accepted only from canonical bridge receiver path.
3. Add anti-replay keying over `(originChainId, originTxHash, originLogIndex, depositId)`.
4. Remove operator mint simulation from production runtime path.

Implemented:
1. Relayer no longer calls `relayV3Deposit` in runtime path.
2. Relayer now derives `pending_fill` from hub `PendingDepositRecorded` events and finalizes with prover-fetched proof.
3. Custody registration authority remains exclusively `CANONICAL_BRIDGE_RECEIVER_ROLE` through `HubAcrossReceiver`.

Acceptance criteria:
1. A deposit cannot be credited unless canonical receive is observed/finalized.
2. Replay of same bridge event is rejected.
3. Relayer cannot mint/credit assets outside canonical bridge flow.

---

### P0-3 Internal API authentication and network hardening

Status: In progress (core auth + replay protection implemented).

Current blockers:
- Internal auth is still shared-secret based (no mTLS/service cert identity yet).
- Environment rollout still needs strict ingress policy verification in staging/prod:
  - `INTERNAL_API_ALLOWED_IPS`
  - `INTERNAL_API_REQUIRE_PRIVATE_IP`
  - `INTERNAL_API_TRUST_PROXY`
- Caller allowlists must be validated per environment to avoid accidental over-permission.

P0-3 gap note (next actions):
1. Run staged ingress validation with real proxy chain (`INTERNAL_API_TRUST_PROXY`) and confirm no header spoofing path.
2. Lock per-service caller allowlists per environment and add deployment-time config validation.
3. Add key-rotation runbook execution evidence (planned + completed timestamps).
4. Evaluate migration from shared-secret HMAC to mTLS/workload identity for production.

Deliverables:
1. Add service-to-service auth for internal routes:
   - HMAC signing or JWT with short TTL and audience checks.
2. Restrict CORS to trusted origins and private network ingress.
3. Add per-route rate limiting and payload size limits.
4. Add request-id tracing and structured audit logs for privileged actions.

Implemented:
1. HMAC-signed internal request validation added on `indexer` and `prover` for `/internal/*`.
2. Timestamp skew checks + replay cache protection added.
3. `relayer` and `prover` internal calls now sign requests.
4. CORS origin is now configurable via `CORS_ALLOW_ORIGIN` env.
5. API and internal-route rate limiting middleware added to `indexer`, `prover`, and `relayer`.
6. Request-id propagation (`x-request-id`) and structured audit logs added for privileged actions.
7. Production fail-closed startup checks now reject default internal auth secrets.
8. Production fail-closed startup checks now reject `CORS_ALLOW_ORIGIN=*`.
9. Internal auth key rotation support added via `INTERNAL_API_AUTH_PREVIOUS_SECRET`.
10. Signed caller identity (`x-elhub-internal-service`) added and verified on `/internal/*`.
11. Caller allowlists added via `INTERNAL_API_ALLOWED_SERVICES`.
12. Internal network gating added for `/internal/*`:
    - private-IP requirement by default in production
    - explicit allowlist mode via `INTERNAL_API_ALLOWED_IPS`
    - proxy-aware IP evaluation via `INTERNAL_API_TRUST_PROXY`
13. E2E internal calls updated to include signed caller identity.

Acceptance criteria:
1. Unauthenticated requests to `/internal/*` are rejected.
2. Replay and expired signatures are rejected.
3. Internal mutation APIs are not reachable from public internet.

---

### P0-4 Durable persistence and queue correctness

Status: In progress (transactional SQLite path landed; full production rollout still pending).

Current blockers:
- Legacy JSON mode remains default in local/dev until env rollout is flipped:
  - `INDEXER_DB_KIND`
  - `PROVER_STORE_KIND`
- Relayer checkpoint persistence is still JSON-only:
  - `/services/relayer/src/server.ts` (`RELAYER_TRACKING_PATH`)
- Outbox/inbox and dead-letter flows are not implemented yet.

Deliverables:
1. Replace JSON state with Postgres (or equivalent) using transactions.
2. Add outbox/inbox pattern for enqueue + settle updates.
3. Make settle worker idempotent with unique constraints:
   - `batch_id`
   - `intent_id`
   - `deposit_id`
4. Dequeue only after successful settlement receipt.
5. Add dead-letter queue and retry policy with backoff.

Implemented:
1. Prover queue no longer dequeues before successful settlement tx confirmation.
2. Prover batch cursor (`nextBatchId`) persisted to disk state file.
3. Prover enqueue deduplication added by action key.
4. Concurrent flush guard added to avoid overlapping settlement attempts.
5. Added transactional SQLite-backed indexer store (`SqliteIndexerStore`) with durable upsert semantics.
6. Added prover queue/state abstraction with transactional SQLite mode (`SqliteProverQueueStore`).
7. Added atomic queue-ack + batch cursor update on prover settlement success in SQLite mode.
8. Added runtime backend toggles:
   - `INDEXER_DB_KIND=json|sqlite`
   - `PROVER_STORE_KIND=json|sqlite`

Acceptance criteria:
1. Service restart does not lose in-flight actions.
2. Duplicate enqueue does not cause duplicate settlement.
3. Failed settlement leaves actions available for retry.

---

## Phase 1 (Security and Protocol Hardening)

### P1-1 Oracle production integration

Current state:
- Risk reads direct oracle interface, currently used with mocks.

Deliverables:
1. Integrate production price adapters with staleness checks and heartbeat bounds.
2. Add fallback oracle policy and circuit-breaker behavior.
3. Add tests for stale/zero/outlier prices.

Acceptance criteria:
1. Borrow/withdraw/lock operations reject stale prices.
2. Price outage triggers safe-mode behavior without unsafe credit expansion.

---

### P1-2 Governance and role separation

Deliverables:
1. Move contract ownership/admin roles to multisig + timelock.
2. Separate emergency pause roles from config-update roles.
3. Add role revocation and break-glass runbook.

Acceptance criteria:
1. No EOA is single point of failure for protocol-critical controls.
2. Timelock protects risk/config changes in production.

---

### P1-3 Relayer economics and risk controls

Current state:
- Static quote model in relayer (`30 bps`) with no inventory/risk engine.

Deliverables:
1. Dynamic quoting based on inventory, volatility, latency, and gas.
2. Per-asset and per-user relayer exposure limits.
3. Fill throttles and circuit breakers.

Acceptance criteria:
1. Relayer rejects fills outside configured risk envelope.
2. Quote service adapts to liquidity and gas conditions.

---

## Phase 2 (Operational Readiness)

### P2-1 Observability and SRE

Deliverables:
1. Metrics: queue depth, settlement latency, proof generation time, lock failures, fill failures.
2. Distributed tracing across relayer/indexer/prover.
3. Alerting for stuck queue, reorg anomalies, high failure rate.

Acceptance criteria:
1. On-call can detect and triage any failed/stalled lifecycle stage within minutes.

---

### P2-2 CI/CD and environment promotion

Deliverables:
1. Add testnet/mainnet deploy pipeline with explicit env validation.
2. Add pre-deploy simulation checks and post-deploy smoke tests.
3. Add rollback scripts and runbooks.

Acceptance criteria:
1. One-command deterministic deploy per environment.
2. Rollback can be executed within defined recovery target.

---

### P2-3 Security verification program

Deliverables:
1. Add Foundry invariant and fuzz suites for cross-chain lifecycle safety properties.
2. Commission external audit (contracts + critical services).
3. Resolve high/critical issues and publish security notes.

Acceptance criteria:
1. No unresolved high/critical findings before mainnet.

---

## Recommended Execution Order

1. P0-3 Internal API auth.
2. P0-4 Durable persistence and queue correctness.
3. P0-2 Canonical bridge attestation path.
4. P0-1 Real ZK proving pipeline.
5. P1-1 Oracle production integration.
6. P1-2 Governance hardening.
7. P1-3 Relayer risk engine.
8. P2-1/P2-2/P2-3 operational + audit closure.

This order reduces exploit surface early and avoids integrating real proving on top of weak service/data guarantees.

---

## Current Implementation Snapshot (2026-02-22)

This section maps the plan to concrete code paths that are still production-sensitive.

1. Real proving is wired, but circuit semantics are still action-root-only:
   - `/circuits/circom/SettlementBatchRoot.circom`
   - `/services/prover/src/proof.ts`
2. Deposit bridging ingestion is now Across pending-fill + proof-finalization based:
   - `/services/relayer/src/server.ts` (`PendingDepositRecorded` watcher + `finalizePendingDeposit`)
3. Custody bridge credit path is now proof-gated through `HubAcrossReceiver` only:
   - `/contracts/src/hub/HubAcrossReceiver.sol`
   - `/contracts/src/hub/HubCustody.sol`
4. Internal auth hardening is implemented; remaining gap is environment rollout validation:
   - Remaining gap is environment rollout validation, not core enforcement:
     - `/services/indexer/src/server.ts`
     - `/services/prover/src/server.ts`
     - `/services/relayer/src/server.ts`
5. Durable storage rollout is partial:
   - Indexer/prover now support transactional SQLite mode.
   - Relayer checkpointing is still JSON-based.
   - Postgres migration and outbox/DLQ are still pending.

---

## Phase 0 Detailed Delivery Backlog

Use this as the execution-level checklist under the P0 epics above.

### P0-3 Internal API auth and network hardening (finish first)

Implementation tasks:
1. Enforce fail-closed startup in non-dev:
   - Refuse startup when `INTERNAL_API_AUTH_SECRET` is default.
   - Refuse startup when `CORS_ALLOW_ORIGIN=*` in production mode.
2. Move internal endpoints behind private network boundary (VPC/private ingress only).
3. Add key rotation support:
   - Active key + previous key overlap window.
   - Rotation runbook tested in staging.
4. Add explicit request audit fields to all privileged mutations:
   - request id, caller service, route, result, latency.

Verification artifacts:
1. Automated test proving unsigned, stale, replayed, and malformed requests are rejected.
2. Staging penetration test report for `/internal/*` exposure.
3. Runbook for key rotation and incident revocation.

Exit criteria:
1. No public ingress path can invoke any `/internal/*` route.
2. Secrets can be rotated without downtime.

---

### P0-4 Durable persistence and queue correctness

Progress note:
1. Transactional SQLite mode is now available for `indexer` and `prover` as an interim durable backend.
2. Final target remains Postgres for production rollout and cross-service operational consistency.

Implementation tasks:
1. Replace JSON files with Postgres tables for:
   - intents
   - deposits
   - prover_action_queue
   - settlement_batches
   - relayer_checkpoints
2. Make enqueue + state transitions transactional.
3. Add unique constraints for idempotency:
   - `deposit_id`
   - `intent_id`
   - `batch_id`
   - deterministic action key
4. Add worker lease/lock so only one flush worker settles a batch at a time.
5. Add reorg handling:
   - persisted confirmations
   - rollback/replay of unfinalized events
6. Add dead-letter queue with bounded retries and backoff policy.

Verification artifacts:
1. Crash-recovery test: restart mid-flush and confirm no double-settlement.
2. Duplicate ingestion test: same event replay does not duplicate accounting.
3. Reorg simulation test with rollback + replay preserving correctness.

Exit criteria:
1. RPO = 0 for accepted intents/deposits/actions.
2. No duplicate settlement under retries, restart, or replay.

---

### P0-2 Canonical bridge attestation path

Implementation tasks:
1. Introduce canonical bridge observer:
   - spoke send observed
   - hub receive observed
   - finality depth satisfied before credit eligibility
2. Define attestation identity key:
   - `(originChainId, originTxHash, originLogIndex, depositId)`
3. Enforce custody registration only from canonical receiver adapter path.
4. Remove relayer mint simulation from production path and gate any simulation under explicit dev-only flag.
5. Persist attestation metadata in indexer/prover pipeline and include it in settlement audit trail.

Verification artifacts:
1. Integration test where missing hub receive prevents settlement credit.
2. Replay test where the same bridge event cannot be re-used.
3. Negative test proving relayer cannot mint/credit in production mode.

Exit criteria:
1. Every credited deposit is cryptographically and operationally linked to a canonical bridge receive event.

---

### P0-1 Real ZK proving semantics

Implementation tasks:
1. Extend circuit to constrain protocol semantics, not only action root:
   - deposit validity linkage
   - lock/fill linkage
   - amount/fee consistency checks
2. Regenerate proving/verifying keys from audited circuit and pin artifact versions.
3. Deploy generated verifier and wire through `Groth16VerifierAdapter`.
4. Freeze `publicInputs` schema and version it.
5. Add proof generation performance budget tests at batch size 50.

Verification artifacts:
1. Reintroduce a canonical circuit-mode E2E command only after deposit proof generation is circuit-compatible with pending-fill finalization.
2. Contract tests proving tampered proof/public inputs are rejected.
3. Benchmark report with proof generation and settlement gas at action counts 1, 10, 25, 50.

Exit criteria:
1. Production runtime runs with `PROVER_MODE=circuit` and `HUB_VERIFIER_DEV_MODE=0` only.
2. Finalized verifier contract address is pinned per environment.

---

## Production Configuration Guardrails (Fail Closed)

These checks should be implemented as startup assertions and deploy-time validations.

1. Services fail startup in production if:
   - internal auth secret is default
   - CORS origin is wildcard
   - required RPC/contract addresses are missing
2. Deployment fails if:
   - verifier is in dev mode
   - generated verifier address is zero or has no bytecode
   - canonical bridge adapter is unset for enabled assets
3. Relayer production mode must explicitly disable simulation code paths.
4. CI must block merge if readiness checks fail.

---

## Mainnet Go/No-Go Gates

All gates are mandatory before mainnet.

1. Security gate:
   - external audit complete
   - all high/critical findings fixed
   - emergency pause + role separation tested
2. Protocol correctness gate:
   - fork E2E for supply/repay and borrow/withdraw green
   - invariant/fuzz suites green
   - reorg/replay tests green
3. Operational gate:
   - dashboards and alerts live
   - on-call runbook dry-run complete
   - rollback rehearsal completed on testnet
4. Performance gate:
   - p95 settlement latency within target
   - proof generation SLO within target
   - no sustained queue growth under expected load

Target SLOs (initial):
1. Settlement latency p95: <= 120s.
2. Proof generation p95 for 50 actions: <= 60s.
3. Failed settlement retry success within 3 attempts for transient faults.
4. Detection-to-page time for stuck queue: <= 2 minutes.

---

## Suggested 6-Week Execution Cadence

1. Week 1: finish P0-3 fail-closed auth/network posture and rotation runbook.
2. Week 2: implement Postgres schema + transactional queue ingestion (P0-4).
3. Week 3: complete flush idempotency, reorg handling, and crash-recovery tests (P0-4).
4. Week 4: ship canonical bridge attestation ingestion + custody enforcement (P0-2).
5. Week 5: finalize semantic circuit constraints and regenerate verifier artifacts (P0-1).
6. Week 6: full staging dress rehearsal, SLO validation, and go/no-go review.
